<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>123k.pl</title>
    <description>Random stuff about music, bikes and programming
</description>
    <link>http://123k.pl/</link>
    <atom:link href="http://123k.pl/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 07 Jan 2016 19:07:34 +0100</pubDate>
    <lastBuildDate>Thu, 07 Jan 2016 19:07:34 +0100</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Leaflet, GeoJSON and Messagepack</title>
        <description>&lt;h1 id=&quot;hypothesis-geo-data-is-good-for-message-pack&quot;&gt;Hypothesis: Geo-data is good for message-pack&lt;/h1&gt;
&lt;p&gt;When I learned about &lt;a href=&quot;http://msgpack.org&quot;&gt;MessagePack&lt;/a&gt; recently, I thought I should check if this optimization is useful for
geo-data. With leaflet one either consumes GeoJSON or simple lists of points to draw lines and points on the map. This json-data
has essentially zero string-payload and is stuffed with small arrays of floats representing the points &lt;code class=&quot;highlighter-rouge&quot;&gt;[50.9668440185,20.0263859611]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So my first feeling was, that there should be a huge safe when this information is not transported as string-literal but as a binary float.
A small test on the &lt;a href=&quot;http://msgpack.org/index.html&quot;&gt;Try It!&lt;/a&gt; yielded:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-console&quot; data-lang=&quot;console&quot;&gt;JSON 29 bytes: [50.7989240717,20.4648714792]
MessagePack (hex) 19 bytes: 92 cb 40 49 66 43 24 db f8 26 cb 40 34 77 01 d1 38 01 d4&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This would be a saving of 33%. Not so bad! That was my first impression. But then again. Wait..
Why needs the msgpack that much bytes?&lt;/p&gt;

&lt;h1 id=&quot;proof-digging-a-likkle-bit-deeper&quot;&gt;Proof: Digging a likkle bit deeper&lt;/h1&gt;
&lt;p&gt;So msgpack decided to encode us the following &lt;code class=&quot;highlighter-rouge&quot;&gt;92 cb 40 49 66 43 24 db f8 26 cb 40 34 77 01 d1 38 01 d4&lt;/code&gt;. We try a little
reverse-engineering now. According to the &lt;a href=&quot;https://github.com/msgpack/msgpack/blob/master/spec.md#formats-float&quot;&gt;spec&lt;/a&gt;
We have two ‘IEEE 754 double precision floating point number’ stored as ‘float 64’. This can be easily seen because of the &lt;code class=&quot;highlighter-rouge&quot;&gt;cb&lt;/code&gt; parts.
Things are getting even worse when we wanted to transmit &lt;code class=&quot;highlighter-rouge&quot;&gt;[20.12,50.34]&lt;/code&gt;. This are 13 JSON bytes and again 19 msg-pack bytes. 30% more this time.&lt;/p&gt;

&lt;p&gt;So the questions is: Can the number 50.9668440185 be displayed with single precision also?
Actually I should be able to really calculate this on paper, as playing with arbitrary floating point definitions was a cornerstone of the first semester at university… but I have to admit, that I’m not really able to do it right now.&lt;/p&gt;

&lt;p&gt;So a small brute-force test on the rust playground has to help and it shows us, that the answer is: No.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;fn main() {
    let x: f32 = 51.0237269662;
    println!(&amp;quot;The value of x is: {}&amp;quot;, x);
    // The value of x is: 51.023727
    let y: f64 = 51.0237269662;
    println!(&amp;quot;The value of y is: {}&amp;quot;, y);
    // The value of y is: 51.0237269662
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/efwe/de3a3d18b755afb68ec0.js?file=test.rs&quot;&gt; &lt;/script&gt;

&lt;p&gt;Why exactly the msgpack-playground used float 64 for the test with &lt;code class=&quot;highlighter-rouge&quot;&gt;20.12&lt;/code&gt;? I don’t know.
For our use-case with the geo-points &lt;strong&gt;we have to stick with the float 64 variant and the maximum saving would be 33%&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&quot;using-msgpack-with-rails-and-coffee-script&quot;&gt;Using msgpack with rails and coffee-script&lt;/h1&gt;
&lt;p&gt;After we saw, that there could be a substantial space saving on the wire with msgpack for our data we can try to really use it.
Right now if have a special rails controler with &lt;code class=&quot;highlighter-rouge&quot;&gt;layout nil&lt;/code&gt; which does the same thing again and again. Rendering json for requests.
After some investigation and registering the mime-type in initilizers/mime_types.rb &lt;code class=&quot;highlighter-rouge&quot;&gt;Mime::Type.register &quot;application/msgpack&quot;, :msgpack&lt;/code&gt;
I eventually could have methods like this:&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;  def coverage
    points = TrackPoint.mongo_client[:coverage].find.first
    respond_to do |format|
      format.json { render :json =&amp;gt; points, :content_type =&amp;gt; &amp;#39;application/json&amp;#39; }
      format.msgpack { send_data MessagePack.pack(points), :type =&amp;gt; &amp;#39;application/msgpack&amp;#39;, :disposition =&amp;gt; &amp;#39;inline&amp;#39; }
    end
  end
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/efwe/fb0188666fc6228b13e2.js?file=coverage_controller.rb&quot;&gt; &lt;/script&gt;

&lt;p&gt;on client side my coffee uses plain jquery&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;addCoverage: () -&amp;gt;
  callback = (response) =&amp;gt;
    points = new L.glify.Points({map: @map, click: @pointClicked, data: response, color: &amp;#39;black&amp;#39;})
  $.get &amp;#39;/map/coverage&amp;#39;, callback, &amp;#39;json&amp;#39;&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/efwe/683e7db0c4c22f5a52d4.js?file=add_coverage.coffee&quot;&gt; &lt;/script&gt;

</description>
        <pubDate>Thu, 07 Jan 2016 14:20:08 +0100</pubDate>
        <link>http://123k.pl/rails/leaflet/message-pack/2016/01/07/leaflet-geojson-and-messagepack.html</link>
        <guid isPermaLink="true">http://123k.pl/rails/leaflet/message-pack/2016/01/07/leaflet-geojson-and-messagepack.html</guid>
        
        
        <category>rails</category>
        
        <category>leaflet</category>
        
        <category>message-pack</category>
        
      </item>
    
      <item>
        <title>Many Clickable Points on a Leaflet Map With Leaflet.glify</title>
        <description>&lt;h1 id=&quot;problem&quot;&gt;Problem&lt;/h1&gt;
&lt;p&gt;As seen in the &lt;a href=&quot;http://localhost:4000/rails/mongodb/2016/01/02/build-a-coverage-map-with-mongodb.html&quot;&gt;post before&lt;/a&gt;
we collected some 12.000 points which we want to display on a leaflet map.
Every attempt to put that many points on one map failed. Firefox completely stopped working, chrome did
a  little bit better and stayed responsive, but that was not a solution at all.&lt;/p&gt;

&lt;h1 id=&quot;solution&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;I pretty much tried everything &lt;code class=&quot;highlighter-rouge&quot;&gt;L.geoJSON&lt;/code&gt; layer with points and polygons.
Where polygons would have been a solution maybe, but you can not tell leaflet to just draw the corners of the polygons.
So I needed something else. In the &lt;code class=&quot;highlighter-rouge&quot;&gt;#leaflet&lt;/code&gt; on freenode i was pointed to the
&lt;a href=&quot;http://robertleeplummerjr.github.io/Leaflet.glify/&quot;&gt;Leaflet.glify&lt;/a&gt; project.&lt;/p&gt;

&lt;p&gt;As I understood, there is a leaflet layer which provides a HTML5 canvas. The location of the points on the canvas is
calculated based on the GPS coordinates (points2pixel) and then are rendered on the canvas with some WebGL point shapes.&lt;/p&gt;

&lt;p&gt;So far so good. The best part is, that the lib holds an index about every rendered point and so can respond to clicks.
As it is not easy to really hit a special point there is even a ‘find nearest point’ algorithm in place so that you almost
always get a point clicked.&lt;/p&gt;

&lt;p&gt;The actual code to use the plugin is a one-liner.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;addCoverage: () -&amp;gt;
  callback = (response) =&amp;gt;
    points = new L.glify.Points({map: @map, click: @pointClicked, data: response, color: &amp;#39;black&amp;#39;})
  $.get &amp;#39;/map/coverage&amp;#39;, callback, &amp;#39;json&amp;#39;&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/efwe/683e7db0c4c22f5a52d4.js?file=add_coverage.coffee&quot;&gt; &lt;/script&gt;

&lt;p&gt;Here’s the callback I use when a point is clicked. Interesting detail. You should call &lt;code class=&quot;highlighter-rouge&quot;&gt;L.DomEvent.stopPropagation(event)&lt;/code&gt; to
stop the event handling if you have other click-backs registered on your map.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;pointClicked: (point, options, event) -&amp;gt;
  if @marker
    @map.removeLayer(@marker)
  @marker = L.marker(point).addTo(@map)
  clickBack = (event) -&amp;gt;
    L.DomEvent.stopPropagation(event)
  @marker.on(&amp;#39;click&amp;#39;, clickBack)

  callback = (response) =&amp;gt;
    if @geoJsonLayer
      @map.removeLayer(@geoJsonLayer)
    @geoJsonLayer = L.geoJson(response,{
      onEachFeature: (feature, layer) =&amp;gt;
        @marker.bindPopup(&amp;#39;&amp;lt;a href=&amp;quot;geo/routes/&amp;#39;+feature.properties.route_id.$oid+&amp;#39;&amp;quot;&amp;gt;&amp;#39;+feature.properties.route_title+&amp;#39;&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;&amp;#39;+feature.properties.route_start)
    })
    @map.addLayer(@geoJsonLayer)
  $.get &amp;#39;/map/routes/to/&amp;#39; + point[0] + &amp;#39;/&amp;#39; + point[1], callback, &amp;#39;json&amp;#39;&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/efwe/28c03b9c10c15cfda165.js?file=point_clicked.coffee&quot;&gt; &lt;/script&gt;

&lt;p&gt;You can see the result at &lt;a href=&quot;https://123k.org/coverage&quot;&gt;https://123k.org/coverage&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;bleeding-edge&quot;&gt;Bleeding Edge&lt;/h1&gt;
&lt;p&gt;At the time of this writing &lt;a href=&quot;http://leafletjs.com&quot;&gt;LeafletJS&lt;/a&gt; is reaching 1.0 and the plugin did not work with it out
of the box. &lt;a href=&quot;https://github.com/efwe/Leaflet.glify/tree/leaflet-1.0&quot;&gt;Here&lt;/a&gt; you find a quick-fix I did.&lt;/p&gt;
</description>
        <pubDate>Thu, 07 Jan 2016 09:29:50 +0100</pubDate>
        <link>http://123k.pl/leaflet/2016/01/07/many-clickable-points-on-a-leaflet-map-with-leaflet-glify.html</link>
        <guid isPermaLink="true">http://123k.pl/leaflet/2016/01/07/many-clickable-points-on-a-leaflet-map-with-leaflet-glify.html</guid>
        
        
        <category>leaflet</category>
        
      </item>
    
      <item>
        <title>Build a Coverage Map With MongoDB</title>
        <description>&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;When I started with my personal bike-track homepage at &lt;a href=&quot;https://123k.org&quot;&gt;123k.org&lt;/a&gt; a few years ago i decided to put all my tracks
in a MongoDB. The model I use is very simple. I have a class &lt;code class=&quot;highlighter-rouge&quot;&gt;Route&lt;/code&gt; which holds meta-data about the track
and a class &lt;code class=&quot;highlighter-rouge&quot;&gt;TrackPoint&lt;/code&gt; which represents a point and has a foreign key to the respective track (of course).
After some years I have 284792 track-points. So 300k entries is not ‘big-data’ exactly,
but it is too much to be displayed on a leaflet map at once. What I really wanted is a ‘Coverage View’, which just
shows me where I’ve been with the bike.&lt;/p&gt;

&lt;h1 id=&quot;the-algorithm&quot;&gt;The algorithm&lt;/h1&gt;

&lt;p&gt;As I start all of my rides at my home and eventually return there I have a center where to start the coverage.
From there I started the following algorithm.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;step = 0.1 # all points within 100 meters
points = []
(1..500).each { |i| # for the next 50km
  min_distance = ((i-1)*step)/EARTH_RADIUS
  max_distance = (i*step)/EARTH_RADIUS
  hull = hull_for min_distance, max_distance # calculate the convex hull for the points in this area
  unless hull.empty?
    #remap once more
    hull.each { |p|
      points &amp;lt;&amp;lt; [p[1], p[0]] # remember points
    }
  end
  if i%100==0
    Rails.logger.info &amp;quot;Finished &amp;quot;+(i/10).to_s+&amp;quot; km&amp;quot;
  end
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/efwe/65e28c72c9948da0e9f8.js?file=coverage.rb&quot;&gt; &lt;/script&gt;

&lt;p&gt;It does 100m steps for 50km and selects all points in the area between min/max distance.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;def hull_for(min_distance, max_distance)
  client = TrackPoint.mongo_client
  points = []
  client.command({geoNear: &amp;#39;track_points&amp;#39;, near: [20.459423, 50.799929] , spherical: true, num: 15000, minDistance: min_distance, maxDistance: max_distance, distanceMultiplier: EARTH_RADIUS}).each { |document|
    document[&amp;#39;results&amp;#39;].each do |point|
      points &amp;lt;&amp;lt; point[&amp;#39;obj&amp;#39;][&amp;#39;location&amp;#39;]
    end
  }
  result = []
  if points.empty?
    Rails.logger.warn &amp;#39;no hull for no points - returning empty hull[]&amp;#39;
  else
    hull_polygon = HullCalc.convex_hull points
    Rails.logger.info &amp;quot;calculated hull polygon with #{hull_polygon.size} points from a total of #{points.size} points&amp;quot;
    result = hull_polygon
  end
  result
end
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/efwe/675f2d2d56470933aaa5.js?file=hull_for.rb&quot;&gt; &lt;/script&gt;

&lt;p&gt;The trick is, that I only consider the points of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Convex_hull&quot;&gt;convex hull&lt;/a&gt;.
I chose the Jarvis March algorithm as completely described &lt;a href=&quot;http://tomswitzer.net/2009/12/jarvis-march/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is very efficient, most of the points are not considered (A random output of my job is
&lt;code class=&quot;highlighter-rouge&quot;&gt;calculated hull polygon with 22 points from a total of 2217 points&lt;/code&gt;). Finally I only have 12033 points left.
The resulting points are stored as one document in MongoDB.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;TrackPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;mongo_client&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:coverage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;drop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:coverage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;insert_one&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:points&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can see the result of this &lt;a href=&quot;https://123k.org/map/coverage&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Jan 2016 19:38:06 +0100</pubDate>
        <link>http://123k.pl/rails/mongodb/2016/01/02/build-a-coverage-map-with-mongodb.html</link>
        <guid isPermaLink="true">http://123k.pl/rails/mongodb/2016/01/02/build-a-coverage-map-with-mongodb.html</guid>
        
        
        <category>rails</category>
        
        <category>mongodb</category>
        
      </item>
    
  </channel>
</rss>
