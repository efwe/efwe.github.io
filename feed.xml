<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>123k.pl</title>
    <description>Random stuff about music, bikes and programming
</description>
    <link>http://123k.pl/</link>
    <atom:link href="http://123k.pl/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 14 Jan 2016 13:18:45 +0100</pubDate>
    <lastBuildDate>Thu, 14 Jan 2016 13:18:45 +0100</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Show routes to current geohash</title>
        <description>&lt;h1 id=&quot;the-plan&quot;&gt;The plan&lt;/h1&gt;
&lt;p&gt;My geohashing alert-system at &lt;a href=&quot;https://123k.org/geohashing&quot;&gt;123k.org&lt;/a&gt; shows the current &lt;a href=&quot;http://wiki.xkcd.com/geohashing/&quot;&gt;geohash&lt;/a&gt; for my home &lt;a href=&quot;https://en.wikipedia.org/wiki/Geographic_coordinate_system&quot;&gt;graticule&lt;/a&gt;. The plan is to the nearest route which passes by.&lt;/p&gt;

&lt;h1 id=&quot;finding-something&quot;&gt;Finding something&lt;/h1&gt;
&lt;p&gt;As mentioned &lt;a href=&quot;http://123k.pl/rails/mongodb/2016/01/02/build-a-coverage-map-with-mongodb.html&quot;&gt;earlier&lt;/a&gt; I have all points i ever visited in a collection.
This collection holds a &lt;a href=&quot;https://docs.mongodb.org/manual/applications/geospatial-indexes/&quot;&gt;geospatial index&lt;/a&gt;. Therefore I can issue mongo queries with
the &lt;code class=&quot;highlighter-rouge&quot;&gt;$nearSphere&lt;/code&gt; command. This command finds the first points from a given location.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt; def route_to
    lat = params[:lat].to_f
    lon = params[:lon].to_f
    first_point = TrackPoint.where({:location =&amp;gt; {&amp;#39;$nearSphere&amp;#39; =&amp;gt; [lat, lon]}}).limit(1).first()
    route = Route.find(first_point.route_id)
    gjson_line = {
        :type =&amp;gt; &amp;quot;Feature&amp;quot;,
        :geometry =&amp;gt; {
            :type =&amp;gt; &amp;quot;LineString&amp;quot;,
            :coordinates =&amp;gt; route.track_points.map { |p| p.location }
        }
    }
    feature_collection = {
        :type =&amp;gt; &amp;quot;FeatureCollection&amp;quot;,
        :features =&amp;gt; [gjson_line]
    }
    render :json =&amp;gt; Yajl::Encoder.encode(feature_collection), :content_type =&amp;gt; &amp;#39;application/json&amp;#39;
  end
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/efwe/c73ab0d887110156c2f9.js?file=first_route.rb&quot;&gt; &lt;/script&gt;

&lt;p&gt;So this just works. But what about other routes which may also be nice and just around the corner?
We can select many points around the hash point and check which routes they’re on.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt; def routes_to
    lat = params[:lat].to_f
    lon = params[:lon].to_f
    features = []
    TrackPoint.collection.aggregate([{&amp;#39;$geoNear&amp;#39; =&amp;gt; {near: [lon, lat], spherical: true, num: 500, maxDistance: 5/6371, distanceMultiplier: 6371, distanceField: &amp;#39;dist.calculated&amp;#39;}}, {&amp;#39;$group&amp;#39; =&amp;gt; {&amp;#39;_id&amp;#39; =&amp;gt; &amp;#39;$route_id&amp;#39;}}]).each { |route_id|
      route = Route.find(route_id[:_id])
      gjson_line = {
          :type =&amp;gt; &amp;quot;Feature&amp;quot;,
          :geometry =&amp;gt; {
              :type =&amp;gt; &amp;quot;LineString&amp;quot;,
              :coordinates =&amp;gt; route.track_points.map { |p| p.location }
          }
      }
      features &amp;lt;&amp;lt; gjson_line
    }

    feature_collection = {
        :type =&amp;gt; &amp;quot;FeatureCollection&amp;quot;,
        :features =&amp;gt; features
    }
    render :json =&amp;gt; Yajl::Encoder.encode(feature_collection), :content_type =&amp;gt; &amp;#39;application/json&amp;#39;
  end
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/efwe/dfc73a236cfc94ef3313.js?file=routes_to.rb&quot;&gt; &lt;/script&gt;

&lt;p&gt;The trick here is that we have a implicit &lt;code class=&quot;highlighter-rouge&quot;&gt;distinct&lt;/code&gt; by grouping the points according to their route-id. So we really find
every route within 5km just once.&lt;/p&gt;

&lt;p&gt;So this also works, but it is not 100% predictable &lt;em&gt;how many&lt;/em&gt; routes we really find. If the point sits just around the corner,
this algorithm will find tons of routes which then are all queried and displayed. Also not useful. I’ll have to invent a custom
&lt;code class=&quot;highlighter-rouge&quot;&gt;limit&lt;/code&gt; here. Or I find a solution to limit the results of the aggregation run - this is just open now.&lt;/p&gt;

&lt;p&gt;I think I’ll stick with the first approach as it nicely stops finding things after the first point and as nobody really
uses my site anyways I provide the second approach via button click.&lt;/p&gt;

&lt;h1 id=&quot;showing-the-routes&quot;&gt;Showing the routes&lt;/h1&gt;
&lt;p&gt;Showing the routes is dead easy again. We just fetch some geo-json and add it to the map:&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;  firstRouteToPoint: (hashPoint) -&amp;gt;
    callback = (response) =&amp;gt;
      L.geoJson(response).addTo(@map)
    $.get &amp;#39;/map/first/route/to/&amp;#39; + hashPoint[0] + &amp;#39;/&amp;#39; + hashPoint[1], callback, &amp;#39;json&amp;#39;

  addRoutesToPoint: (hashPoint) -&amp;gt;
    callback = (response) =&amp;gt;
      L.geoJson(response, {
        style: (feature) =&amp;gt;
          return {color: @random_color()}
      }).addTo(@map)
    $.get &amp;#39;/map/routes/to/&amp;#39; + hashPoint[0] + &amp;#39;/&amp;#39; + hashPoint[1], callback, &amp;#39;json&amp;#39;

  random_color: () -&amp;gt;
    letters = &amp;#39;0123456789ABCDEF&amp;#39;.split(&amp;#39;&amp;#39;)
    color = &amp;#39;#&amp;#39;
    color += letters[Math.round(Math.random() * 15)] for [0..5]
    color

&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/efwe/c78ad24bad8368412b4f.js?file=show_routes.coffee&quot;&gt; &lt;/script&gt;

&lt;p&gt;As my geohashing page shows the whole graticule, but my bike-rides just cover some 20km radius I only display the
route when the point sits within 35km of my home. So we need a distance calculation. This is again easy as leaflet just provides
this.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-coffee-script&quot; data-lang=&quot;coffee-script&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;latLng&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;vi&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;distanceTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;latLng&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;lon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;35000&lt;/span&gt;
  &lt;span class=&quot;vi&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;firstRouteToPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;lat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As this feature is not visible every day I took a screenshot for reference. You can see, that the additional routes are not
100% useful, especially because they are not clickable yet. But this is another feature.
&lt;img src=&quot;/assets/images/displayed_routes.png&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 13 Jan 2016 15:28:00 +0100</pubDate>
        <link>http://123k.pl/leaflet/mongodb/geohashing/2016/01/13/show-routes-to-current-geohash.html</link>
        <guid isPermaLink="true">http://123k.pl/leaflet/mongodb/geohashing/2016/01/13/show-routes-to-current-geohash.html</guid>
        
        
        <category>leaflet</category>
        
        <category>mongodb</category>
        
        <category>geohashing</category>
        
      </item>
    
      <item>
        <title>Many Clickable Points on a Leaflet Map With Leaflet.glify</title>
        <description>&lt;h1 id=&quot;problem&quot;&gt;Problem&lt;/h1&gt;
&lt;p&gt;As seen in the &lt;a href=&quot;http://123k.pl/rails/mongodb/2016/01/02/build-a-coverage-map-with-mongodb.html&quot;&gt;post before&lt;/a&gt;
we collected some 12.000 points which we want to display on a leaflet map.
Every attempt to put that many points on one map failed. Firefox completely stopped working, chrome did
a  little bit better and stayed responsive, but that was not a solution at all.&lt;/p&gt;

&lt;h1 id=&quot;solution&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;I pretty much tried everything &lt;code class=&quot;highlighter-rouge&quot;&gt;L.geoJSON&lt;/code&gt; layer with points and polygons.
Where polygons would have been a solution maybe, but you can not tell leaflet to just draw the corners of the polygons.
So I needed something else. In the &lt;code class=&quot;highlighter-rouge&quot;&gt;#leaflet&lt;/code&gt; on freenode i was pointed to the
&lt;a href=&quot;http://robertleeplummerjr.github.io/Leaflet.glify/&quot;&gt;Leaflet.glify&lt;/a&gt; project.&lt;/p&gt;

&lt;p&gt;As I understood, there is a leaflet layer which provides a HTML5 canvas. The location of the points on the canvas is
calculated based on the GPS coordinates (points2pixel) and then are rendered on the canvas with some WebGL point shapes.&lt;/p&gt;

&lt;p&gt;So far so good. The best part is, that the lib holds an index about every rendered point and so can respond to clicks.
As it is not easy to really hit a special point there is even a ‘find nearest point’ algorithm in place so that you almost
always get a point clicked.&lt;/p&gt;

&lt;p&gt;The actual code to use the plugin is a one-liner.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;addCoverage: () -&amp;gt;
  callback = (response) =&amp;gt;
    points = new L.glify.Points({map: @map, click: @pointClicked, data: response, color: &amp;#39;black&amp;#39;})
  $.get &amp;#39;/map/coverage&amp;#39;, callback, &amp;#39;json&amp;#39;&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/efwe/683e7db0c4c22f5a52d4.js?file=add_coverage.coffee&quot;&gt; &lt;/script&gt;

&lt;p&gt;Here’s the callback I use when a point is clicked. Interesting detail. You should call &lt;code class=&quot;highlighter-rouge&quot;&gt;L.DomEvent.stopPropagation(event)&lt;/code&gt; to
stop the event handling if you have other click-backs registered on your map.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;pointClicked: (point, options, event) -&amp;gt;
  if @marker
    @map.removeLayer(@marker)
  @marker = L.marker(point).addTo(@map)
  clickBack = (event) -&amp;gt;
    L.DomEvent.stopPropagation(event)
  @marker.on(&amp;#39;click&amp;#39;, clickBack)

  callback = (response) =&amp;gt;
    if @geoJsonLayer
      @map.removeLayer(@geoJsonLayer)
    @geoJsonLayer = L.geoJson(response,{
      onEachFeature: (feature, layer) =&amp;gt;
        @marker.bindPopup(&amp;#39;&amp;lt;a href=&amp;quot;geo/routes/&amp;#39;+feature.properties.route_id.$oid+&amp;#39;&amp;quot;&amp;gt;&amp;#39;+feature.properties.route_title+&amp;#39;&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;&amp;#39;+feature.properties.route_start)
    })
    @map.addLayer(@geoJsonLayer)
  $.get &amp;#39;/map/routes/to/&amp;#39; + point[0] + &amp;#39;/&amp;#39; + point[1], callback, &amp;#39;json&amp;#39;&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/efwe/28c03b9c10c15cfda165.js?file=point_clicked.coffee&quot;&gt; &lt;/script&gt;

&lt;p&gt;You can see the result at &lt;a href=&quot;https://123k.org/coverage&quot;&gt;https://123k.org/coverage&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;bleeding-edge&quot;&gt;Bleeding Edge&lt;/h1&gt;
&lt;p&gt;At the time of this writing &lt;a href=&quot;http://leafletjs.com&quot;&gt;LeafletJS&lt;/a&gt; is reaching 1.0 and the plugin did not work with it out
of the box. &lt;a href=&quot;https://github.com/efwe/Leaflet.glify/tree/leaflet-1.0&quot;&gt;Here&lt;/a&gt; you find a quick-fix I did.&lt;/p&gt;
</description>
        <pubDate>Thu, 07 Jan 2016 09:29:50 +0100</pubDate>
        <link>http://123k.pl/leaflet/2016/01/07/many-clickable-points-on-a-leaflet-map-with-leaflet-glify.html</link>
        <guid isPermaLink="true">http://123k.pl/leaflet/2016/01/07/many-clickable-points-on-a-leaflet-map-with-leaflet-glify.html</guid>
        
        
        <category>leaflet</category>
        
      </item>
    
      <item>
        <title>Build a Coverage Map With MongoDB</title>
        <description>&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;When I started with my personal bike-track homepage at &lt;a href=&quot;https://123k.org&quot;&gt;123k.org&lt;/a&gt; a few years ago i decided to put all my tracks
in a MongoDB. The model I use is very simple. I have a class &lt;code class=&quot;highlighter-rouge&quot;&gt;Route&lt;/code&gt; which holds meta-data about the track
and a class &lt;code class=&quot;highlighter-rouge&quot;&gt;TrackPoint&lt;/code&gt; which represents a point and has a foreign key to the respective track (of course).
After some years I have 284792 track-points. So 300k entries is not ‘big-data’ exactly,
but it is too much to be displayed on a leaflet map at once. What I really wanted is a ‘Coverage View’, which just
shows me where I’ve been with the bike.&lt;/p&gt;

&lt;h1 id=&quot;the-algorithm&quot;&gt;The algorithm&lt;/h1&gt;

&lt;p&gt;As I start all of my rides at my home and eventually return there I have a center where to start the coverage.
From there I started the following algorithm.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;step = 0.1 # all points within 100 meters
points = []
(1..500).each { |i| # for the next 50km
  min_distance = ((i-1)*step)/EARTH_RADIUS
  max_distance = (i*step)/EARTH_RADIUS
  hull = hull_for min_distance, max_distance # calculate the convex hull for the points in this area
  unless hull.empty?
    #remap once more
    hull.each { |p|
      points &amp;lt;&amp;lt; [p[1], p[0]] # remember points
    }
  end
  if i%100==0
    Rails.logger.info &amp;quot;Finished &amp;quot;+(i/10).to_s+&amp;quot; km&amp;quot;
  end
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/efwe/65e28c72c9948da0e9f8.js?file=coverage.rb&quot;&gt; &lt;/script&gt;

&lt;p&gt;It does 100m steps for 50km and selects all points in the area between min/max distance.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;def hull_for(min_distance, max_distance)
  client = TrackPoint.mongo_client
  points = []
  client.command({geoNear: &amp;#39;track_points&amp;#39;, near: [20.459423, 50.799929] , spherical: true, num: 15000, minDistance: min_distance, maxDistance: max_distance, distanceMultiplier: EARTH_RADIUS}).each { |document|
    document[&amp;#39;results&amp;#39;].each do |point|
      points &amp;lt;&amp;lt; point[&amp;#39;obj&amp;#39;][&amp;#39;location&amp;#39;]
    end
  }
  result = []
  if points.empty?
    Rails.logger.warn &amp;#39;no hull for no points - returning empty hull[]&amp;#39;
  else
    hull_polygon = HullCalc.convex_hull points
    Rails.logger.info &amp;quot;calculated hull polygon with #{hull_polygon.size} points from a total of #{points.size} points&amp;quot;
    result = hull_polygon
  end
  result
end
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/efwe/675f2d2d56470933aaa5.js?file=hull_for.rb&quot;&gt; &lt;/script&gt;

&lt;p&gt;The trick is, that I only consider the points of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Convex_hull&quot;&gt;convex hull&lt;/a&gt;.
I chose the Jarvis March algorithm as completely described &lt;a href=&quot;http://tomswitzer.net/2009/12/jarvis-march/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is very efficient, most of the points are not considered (A random output of my job is
&lt;code class=&quot;highlighter-rouge&quot;&gt;calculated hull polygon with 22 points from a total of 2217 points&lt;/code&gt;). Finally I only have 12033 points left.
The resulting points are stored as one document in MongoDB.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;TrackPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;mongo_client&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:coverage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;drop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:coverage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;insert_one&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:points&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can see the result of this &lt;a href=&quot;https://123k.org/map/coverage&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Jan 2016 19:38:06 +0100</pubDate>
        <link>http://123k.pl/rails/mongodb/2016/01/02/build-a-coverage-map-with-mongodb.html</link>
        <guid isPermaLink="true">http://123k.pl/rails/mongodb/2016/01/02/build-a-coverage-map-with-mongodb.html</guid>
        
        
        <category>rails</category>
        
        <category>mongodb</category>
        
      </item>
    
  </channel>
</rss>
